#!/usr/bin/python

import argparse
import string
import os
import subprocess
import plistlib


quickpkg_version = '0.0'
supported_extensions = ['dmg', 'app']

# quickpkg

# modeled after munkiimport but to build a pkg


def logger(log, v=0):
    if args.verbosity >= v:
        print log


def cmdexec(command):
    """Execute a command."""
    # if 'command' is a string, split the string into components
    if isinstance(command, str):
        command = command.split()

    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = proc.communicate()

    logger("cmdexec: %s, result: %s, error: %s" % (command, stdout, stderr), 3)

    # strip trailing whitespace, which would mess with string comparisons
    return {"return_code": proc.returncode, "stderr": stderr.rstrip(), "stdout": stdout.rstrip()}


# stolen from munkicommons.py
def getFirstPlist(textString):
    """Gets the next plist from a text string that may contain one or
    more text-style plists.
    Returns a tuple - the first plist (if any) and the remaining
    string after the plist"""
    plist_header = '<?xml version'
    plist_footer = '</plist>'
    plist_start_index = textString.find(plist_header)
    if plist_start_index == -1:
        # not found
        return ("", textString)
    plist_end_index = textString.find(
        plist_footer, plist_start_index + len(plist_header))
    if plist_end_index == -1:
        # not found
        return ("", textString)
    # adjust end value
    plist_end_index = plist_end_index + len(plist_footer)
    return (textString[plist_start_index:plist_end_index],
            textString[plist_end_index:])


def attachdmg(dmgpath):
    attachcmd = ["/usr/bin/hdiutil",
                 "attach",
                 dmgpath,
                 "-mountrandom",
                 "/private/tmp",
                 "-plist",
                 "-nobrowse"]
    result = cmdexec(attachcmd)
    if result["return_code"] == 0:
        # parse the plist output
        (theplist, alltext) = getFirstPlist(result["stdout"])
        resultdict = plistlib.readPlistFromString(theplist)
        volpaths = []
        for x in resultdict["system-entities"]:
            if x["potentially-mountable"]:
                if x["volume-kind"] == 'hfs':
                    volpaths.append(x["mount-point"])
        # return the paths to mounted volume
        return volpaths
    else:
        print "error mounting disk image"
        print "(%d, %s)" % (result["returncode"], result["stderr"])
        exit(1)


def detachpaths(volpaths):
    for x in volpaths:
        if os.path.exists(x):
            if os.path.ismount(x):
                detachcmd = ["/usr/bin/hdiutil", "detach", x]
                cmdexec(detachcmd)


def finditemswithextension(dirpath, item_extension):
    foundapps = []
    if os.path.exists(dirpath):
        for x in os.listdir(dirpath):
            (item_basename, item_extension) = os.path.splitext(x)
            item_extension = string.lstrip(item_extension, '.')
            if item_extension == 'app':
                foundapps.append(os.path.join(dirpath, x))
    else:
        print "path %s does not exist" % dirpath
        exit(1)
    return foundapps


def appNameAndVersion(app_path):
    info_path = os.path.join(app_path, "Contents/Info.plist")
    if not os.path.exists(info_path):
        print "Application at path %s does not have Info.plist" % app_path
        # TODO: cleanup volumes here
        exit(1)
    info_plist = plistlib.readPlist(info_path)
    app_name = info_plist.get("CFBundleName", None)
    app_identifier = info_plist.get("CFBundleIdentifier", None)
    app_version = info_plist.get("CFBundleShortVersionString", None)
    if app_version == None:
        app_version = info_plist.get("CFBundleVersion", None)
    return (app_name, app_identifier, app_version)


if __name__ == "__main__":
    # for convenience link to argparse tutorial:
    # https://docs.python.org/2/howto/argparse.html#id1
    parser = argparse.ArgumentParser(description="Attempts to build a pkg from the input.",
                                     epilog="""Installer item can be a dmg, or app.

        Example:
        quickpkg /path/to/installer_item""", formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('--version', help='prints the version', action='version', version=quickpkg_version)

    # takes a path as input
    parser.add_argument('item_path', help="path to the installer item")

    parser.add_argument("-v", "--verbosity", action="count", default=0, help="controls amount of logging output (max -vvv)")

    args = parser.parse_args()

    # remove trailing '/' from path
    item_path = string.rstrip(args.item_path, '/')

    # get file extension
    (item_basename, item_extension) = os.path.splitext(item_path)
    item_extension = string.lstrip(item_extension, '.')

    # is extension supported
    if item_extension not in supported_extensions:
        print ".%s is not a supported extension!" % item_extension
        exit(1)

    # if item is an app, just pass it on
    if item_extension == 'app':
        if not os.path.exists(item_path):
            print "This does not seem to be an Application!"
            exit(1)

        app_path = item_path

    dmgvolumepaths = []

    # if item is a dmg, mount it and find useful contents
    if item_extension == 'dmg':
        dmgvolumepaths = attachdmg(item_path)
        foundapps = []
        for x in dmgvolumepaths:
            moreapps = finditemswithextension(x, 'app')
            foundapps.extend(moreapps)
        if len(foundapps) == 0:
            print "Could not find an application!"
            detachpaths(dmgvolumepaths)
            exit(1)
        elif len(foundapps) > 1:
            print "Found too many Applications! Can't decide!"
            print foundapps
            detachpaths(dmgvolumepaths)
            exit(1)
        
        app_path = foundapps[0]

    logger("Found application: %s" % app_path, 1)
    
    # extract version and other metadata
    (app_name, app_identifier, app_version) = appNameAndVersion(app_path)

    logger("Name: %s, ID: %s, Version: %s" %(app_name, app_identifier, app_version))

    pkg_name = "{name}-{version}.pkg".format(name=app_name, version=app_version, identifier=app_identifier)

    pkgcmd = ["/usr/bin/pkgbuild",
              "--component", app_path,
              "--identifier", app_identifier,
              "--version", app_version,
              "--install-location", "/Applications",
              pkg_name]
    result = cmdexec(pkgcmd)

    print result["stdout"]
    if result["return_code"] != 0:
        print "Error Code: " + result["return_code"]
        print result["stderr"]

    # run pkgutil to build result
    detachpaths(dmgvolumepaths)

